"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractEvents = exports.getContractAddress = exports.getCodeId = exports.b64ToDict = exports.dictToB64 = void 0;
var TxAPI_1 = require("../client/lcd/api/TxAPI");
/**
 * Serializes a JavaScript object to a Base64-encoded string. If the data passed is
 * already a string, it will not be serialized and just return as-is.
 *
 * @param data object to encode
 * @returns base64-encoded string
 */
function dictToB64(data) {
    // if data is just a plain string, it was not valid Base64-encoded JSON so it could not be parsed
    if (typeof data === 'string') {
        return data;
    }
    else {
        return Buffer.from(JSON.stringify(data)).toString('base64');
    }
}
exports.dictToB64 = dictToB64;
/**
 * Recovers a JavaScript object from a Base64-encoded JSON string. If an error is encountered
 * while parsing, the string will not be converted and fail by returning the input as-is.
 *
 * @param data string
 * @returns converted object
 */
function b64ToDict(data) {
    try {
        return JSON.parse(Buffer.from(data, 'base64').toString());
    }
    catch (_a) {
        return data;
    }
}
exports.b64ToDict = b64ToDict;
function getCodeId(txResult, msgIndex) {
    if (msgIndex === void 0) { msgIndex = 0; }
    if (TxAPI_1.isTxError(txResult) ||
        txResult.logs === undefined ||
        txResult.logs.length === 0) {
        throw new Error('could not parse code id -- tx logs are empty.');
    }
    var codeId = txResult.logs[msgIndex].eventsByType['store_code']['code_id'][0];
    return codeId;
}
exports.getCodeId = getCodeId;
function getContractAddress(txResult, msgIndex) {
    if (msgIndex === void 0) { msgIndex = 0; }
    if (TxAPI_1.isTxError(txResult) ||
        txResult.logs === undefined ||
        txResult.logs.length === 0) {
        throw new Error('could not parse contract address -- tx logs are empty.');
    }
    var contractAddress = txResult.logs[msgIndex].eventsByType['instantiate_contract']['contract_address'][0];
    return contractAddress;
}
exports.getContractAddress = getContractAddress;
function getContractEvents(txResult, msgIndex) {
    if (msgIndex === void 0) { msgIndex = 0; }
    if (TxAPI_1.isTxError(txResult) ||
        txResult.logs === undefined ||
        txResult.logs.length === 0) {
        throw new Error('could not parse contract events -- tx logs are empty.');
    }
    var contractEvents = [];
    for (var _i = 0, _a = txResult.logs[msgIndex].events; _i < _a.length; _i++) {
        var event_1 = _a[_i];
        if (event_1.type === 'from_contract') {
            var eventData = { contract_address: '' }; // will be overwritten
            var currentContractAddress = event_1.attributes[0].value;
            for (var _b = 0, _c = event_1.attributes; _b < _c.length; _b++) {
                var att = _c[_b];
                if (att.key == 'contract_address' &&
                    currentContractAddress !== att.value) {
                    contractEvents.push(eventData);
                    eventData = { contract_address: '' };
                    currentContractAddress = att.value;
                }
                eventData[att.key] = att.value;
            }
            contractEvents.push(eventData);
            return contractEvents;
        }
    }
    throw new Error("could not find event type 'from_contract' in logs");
}
exports.getContractEvents = getContractEvents;
//# sourceMappingURL=contract.js.map